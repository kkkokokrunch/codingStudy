## 透过TCP/IP看HTTP

http协议是构建在tcp/ip协议之上的，是tcp/ip的一个子集

tcp/ip属于传输层，传输层通过系统调用，向应用层提供处于网络连接中的两台计算机之间的数据传输功能

### 三次握手

首先要了解这几个概念：

- SYN和FIN：SYN代表发起一个新连接，FIN代表释放一个连接
- ACK：用来确认收到，**为了确保不丢包**，ACK=1时，代表确认号字段有效，否则无效，在建立连接以后所有传送的报文段都要把ACK设为1
- seq：序号，**用来解决网络包乱序的问题**，用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。
- ack：确认序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。

三次握手：

主要是要初始化Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的Sequence Number（缩写为ISN：Inital Sequence Number）——所以叫SYN，全称Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）

1. 客户端->服务器：SYN=1,seq=x，SYN设为1代表要建立一个新连接，并随机生成一个起始序列号seq，一起发给服务器；
2. 服务器->客户端：SYN=1,ACK=1,ack=x+1,seq=y，服务器看到SYN=1，知道客户端要建立连接，于是发送一个SYN=1和一个ACK=1，由于收到了客户端的seq=x，于是发送一个ack=x+1确认序号回去，再加上一个随机生成的服务器起始序列号seq=y，这四个一起发给客户端；
3. 客户端->服务器：ACK=1,seq=x+1，ack=y+1，客户端看到上面的ACK=1,ack=x+1,知道服务端收到了自己发过去的序列号为x的报文，又因为SYN=1，知道服务端同意连接，于是ACK=1,ack=y+1，告诉服务器自己收到了

因为客户端和服务端都要确认自己的发送能力和接受能力是正常的：

1. 客户端第一次发送，服务端接收，

   此时服务端知道客户端的发送能力以及自己的接收能力正常

2. 服务端接收到客户端的信息以后，第一次发送给客户端，

   客户端接收到以后，客户端知道服务端的发送和接受能力都正常，也知道自己的发送能力和接收能力正常

3. 客户端收到以后，再发送一次信息给服务端，

   服务端收到以后，服务端知道客户端的接受能力也正常，也知道自己的发送能力正常

#### 为什么需要三次握手

一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。

如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。

如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。

#### 为什么要等待2MSL

MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。

第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。

## DNS域名解析

1. 平时大家经常通过主机名或者域名来访问一个网站，因为相对于一串数字的IP地址，域名更容易记忆
2. 但是TCP/IP协议使用的是IP地址进行访问
3. 所以我们需要DNS来将域名解析成IP地址



### 解析流程

1. 系统通常会优先从host文件中寻找对应IP地址，如果找到就直接用
2. 如果host文件中没有，就会去寻找本地的DNS服务
3. 本地没有再根据本地DNS服务器设置来查找，设置中有一项是否设置转发，如果没有转发，直接去根DNS，如果设置了就会一层一层向上找，直到DNS根服务器



## http特性

1. 无连接：无连接的含义是 限制每次连接只处理一个请求，服务器处理完客户的请求，并受到客户的回应，就断开连接
2. 无状态：协议对于事务处理没有记忆能力
3. 简单灵活



## URI和URL

URI = URL+URN

URN就像一个人的名字，URL就像一个人的地址

URN确定了东西的身份，URL提供了找到他的方式





## http报文结构

报文行（请求方法 URI HTTP协议以及版本），报文头，空行，报文正文。



![1583824487606](D:\GitHub\codingStudy\0interview\浏览器与网络\1583824487606.png)



## 报文头的属性

1. Accept：text/html，代表浏览器可以接收服务器返回的类型，也就是常说的html文档；如果服务器无法返回这一类型的数据，那么服务器会返回一个406错误。
2. Accept-Language：代表浏览器接收的语言
3. Connection：keep-alive，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP协议不会关闭，如果客户端再次访问这个服务器上的网页，会继续用这条连接； close代表关闭。
4. User-Agent：告诉服务器，客户端所使用的操作系统和浏览器的名称和版本
5. Content-Type：说明报文体内对象对象的媒体类型     

  

## cookie和session

- cookie存储在客户端（浏览器），session存在服务器；
- 安全性不同，cookie在浏览器可见，但是可以通过加密，再让服务器解密
- 有效期不同，cookie可以保存很长时间，但是服务器会定时处理session信息
- cookie不占用服务器资源，而多个session一起请求会给服务器带来很大压力  



## HTTP缓存

#### HTTP缓存头部字段

1. Cache-Control：请求/响应头，缓存控制字段



  

  

  

  

  





