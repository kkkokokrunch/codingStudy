## 跨域
因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败。
为来防止CSRF攻击
1. JSONP
    JSONP 的原理很简单，就是利用script标签没有跨域限制的漏洞。
    通过script标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。
    ```
    <script src="http://domain/api?param1=a&param2=b&callback=jsonp"></script>
    <script>
        function jsonp(data) {
        	console.log(data)
    	}
    </script>
    ```
    JSONP 使用简单且兼容性不错，但是只限于 get 请求。
2. CORS
    CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。
3. webpack配置proxyTable设置开发环境跨域
4. nginx代理跨域
   
## 前端常用的性能优化方法有哪些？打开页面加载较慢的改进方法有哪些
三个方面来说明前端性能优化
1. webapck优化与开启gzip压缩
    1.babel-loader用 include 或 exclude 来帮我们避免不必要的转译，不转译node_moudules中的js文件
    其次在缓存当前转译的js文件，设置loader: 'babel-loader?cacheDirectory=true'
    2.文件采用按需加载等等
    3.具体的做法非常简单，只需要你在你的 request headers 中加上这么一句：
    accept-encoding:gzip
    4.图片优化，采用svg图片或者字体图标
    5.浏览器缓存机制，它又分为强缓存和协商缓存
2. 本地存储——从 Cookie 到 Web Storage、IndexedDB
    说明一下SessionStorage和localStorage还有cookie的区别和优缺点
3. 代码优化
    1.事件代理
    2.事件的节流和防抖
    3.页面的回流和重绘
    4.EventLoop事件循环机制
    5.代码优化等等


## 回流与重绘
回流：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，
浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），
然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。

重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，
浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘。

由此我们可以看出，重绘不一定导致回流，回流一定会导致重绘。
硬要比较的话，回流比重绘做的事情更多，带来的开销也更大。但这两个说到底都是吃性能的，
所以都不是什么善茬。我们在开发中，要从代码层面出发，尽可能把回流和重绘的次数最小化。


## csrf 跨站请求伪造 XSS
csrf防御措施
1. Token验证
2. referer验证
3. 隐藏令牌


## 浏览器缓存
1. 强缓存
2. 协商缓存





## webSocket

由于HTTP协议通信只能由客户端发起，无法做到服务器主动向客户端推送消息，如果服务器有连续的变化，客户端只能通过**轮询**的方式才能获取消息，这样效率非常低，所以才有了websocket。

