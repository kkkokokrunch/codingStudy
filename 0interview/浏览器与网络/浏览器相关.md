## 跨域
因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败。
为来防止CSRF攻击

1. JSONP
    JSONP 的原理很简单，就是利用script标签没有跨域限制的漏洞。
    通过script标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。
    ```
    <script src="http://domain/api?param1=a&param2=b&callback=jsonp"></script>
    <script>
        function jsonp(data) {
        	console.log(data)
    	}
    </script>
    ```
    JSONP 使用简单且兼容性不错，但是只限于 get 请求。
    
2. CORS
    CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。
    
    浏览器将CORS请求分为两类：
    
    - 简单请求
    - 非简单请求
    
    只要满足以下条件的就是简单请求：
    
    1. 请求方法是以下三种之一：HEAD ,GET,POST
    2. http请求头信息不超过以下几种字段：Accept，Accept-language,Content-language,Last-Event-ID,Content-type只限于三个值：application/x-www-form-urlencoded、multipart/form-data、text/plain
    
    对于简单请求，浏览器直接发出CORS请求，就是在头信息中加一个Origin字段，内容是该请求来自哪个源（协议+域名+端口），服务器根据这个值，决定是否同意此次请求。如果Origin指定的源不在许可范围内，服务器会返回一个正常的http请求，浏览器发现这个响应头内没有Access-Control-Allow-Origin字段，就会报错。
    
    非简单请求会在正式通信之前发送一个HTTP查询请求，成为预检请求，浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的`XMLHttpRequest`请求，否则就报错。
    
    "预检"请求用的请求方法是`OPTIONS`，表示这个请求是用来询问的。头信息里面，关键字段是`Origin`，表示请求来自哪个源。
    
    一旦服务器通过了"预检"请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个`Origin`头信息字段。服务器的回应，也都会有一个`Access-Control-Allow-Origin`头信息字段。
3. webpack配置proxyTable设置开发环境跨域

4. nginx代理跨域

## 前端常用的性能优化方法有哪些？打开页面加载较慢的改进方法有哪些
三个方面来说明前端性能优化
1. webapck优化与开启gzip压缩
    1.babel-loader用 include 或 exclude 来帮我们避免不必要的转译，不转译node_moudules中的js文件
    其次在缓存当前转译的js文件，设置loader: 'babel-loader?cacheDirectory=true'
    2.文件采用按需加载等等
    3.具体的做法非常简单，只需要你在你的 request headers 中加上这么一句：
    accept-encoding:gzip
    4.图片优化，采用svg图片或者字体图标
    5.浏览器缓存机制，它又分为强缓存和协商缓存
2. 本地存储——从 Cookie 到 Web Storage、IndexedDB
    说明一下SessionStorage和localStorage还有cookie的区别和优缺点
3. 代码优化
    1.事件代理
    2.事件的节流和防抖
    3.页面的回流和重绘
    4.EventLoop事件循环机制
    5.代码优化等等


## 回流与重绘
回流：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，
浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），
然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。

重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，
浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘。

由此我们可以看出，重绘不一定导致回流，回流一定会导致重绘。
硬要比较的话，回流比重绘做的事情更多，带来的开销也更大。但这两个说到底都是吃性能的，
所以都不是什么善茬。我们在开发中，要从代码层面出发，尽可能把回流和重绘的次数最小化。


## csrf 跨站请求伪造 XSS
csrf防御措施
1. Token验证
2. referer验证
3. 隐藏令牌


## 浏览器缓存
1. 强缓存
2. 协商缓存


## webSocket

由于HTTP协议通信只能由客户端发起，无法做到服务器主动向客户端推送消息，如果服务器有连续的变化，客户端只能通过**轮询**的方式才能获取消息，这样效率非常低，所以才有了websocket。



## 从输入url到加载完成中间发生了什么？

0. 先检查浏览器有没有缓存，如果有缓存且没有过期，就直接用缓存的内容，如果没有缓存就开始下一步

1. 首先是**DNS解析**：如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来，如果没有的话，会进行DNS迭代查询。

2. 之后就是**TCP握手**：TCP 的握手情况以及 TCP 的一些特性。如果是https的话，还会 TCP 握手结束后就会进行 TLS 握手，然后就开始正式的传输数据。

   **应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了。**

   **数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件。**

3. 接收到响应的文件之后，**首先浏览器会判断状态码是什么**，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向

4. **浏览器开始解析文件**，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件。

5. 文件解码成功后会正式开始**渲染流程**，解析 HTML 文档，构件 DOM 树，下载资源，构造 CSSOM 树，执行 js 脚本，这些操作没有严格的先后顺序，以下分别解释

   - 浏览器无法直接读取html,需要先构建dom树 
   - 渲染引擎（渲染进程）将CSS转换为浏览器可以理解的styleSheets
   - css标准化，比如red -> rgba font-weigth:bold变成数值
   - 计算dom树的具体样式（**回流从这里开始**）
   - 生成布局树（layout)：把不显示的去掉、把每个元素的信息计算出来
   - 分层（layer）：页面都是一层一层叠加在一起形成的，并不是每个节点都会包含一个图层，拥有层叠上下文属性的元素会被提升为单独一层（position，z-index，filter，opacity），需要被裁减的地方也会被创建为图层，还有滚动条也是。
   - 图层绘制（paint）：渲染引擎将一个图层的绘制拆分成若个指令，然后把这些指令按照顺序组成一个待绘制列表（**重绘从这里开始**）
   - 图层绘制列表准备好以后，主线程会将这个绘制列表提交（commit）给合成线程
   - 合成线程就会把分层树的图层变成图块，然后就要将视口附近的图块优先生成位图，这一过程由栅格线程完成。
   - 渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池中进行的，
   - 通常栅格化都会用GPU进行加速，GPU的栅格化把视窗附近的图块变成位图，就是也渲染的最小粒度了，然后保存在GPU的进程中
   - 栅格化完成之后，合成线程生成一个绘制图块的命令DrawQuad，把该命令提交给浏览器进程，浏览器进程根据这个命令，将其页面内容绘制到内存是，再将内存显示在屏幕上。

6. **js 解析如下**：

7. 浏览器创建 Document 对象并解析 HTML，将解析到的元素和文本节点添加到文档中，此时**document.readystate 为 loading**

8. HTML 解析器遇到**没有 async 和 defer 的 script 时**，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用 document.write()把文本插入到输入流中。**同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作 script 和他们之前的文档内容**

9. 当解析器遇到设置了**async**属性的 script 时，开始下载脚本并继续解析文档。脚本会在它**下载完成后尽快执行**，但是**解析器不会停下来等它下载**。异步脚本**禁止使用 document.write()**，它们可以访问自己 script 和之前的文档元素

10. 当文档完成解析，document.readState 变成 interactive

11. 所有**defer**脚本会**按照在文档出现的顺序执行**，延迟脚本**能访问完整文档树**，禁止使用 document.write()

12. 浏览器**在 Document 对象上触发 DOMContentLoaded 事件**

13. 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些**内容完成载入并且所有异步脚本完成载入和执行**，document.readState 变为 complete,window 触发 load 事件

> 另外就是：
>
> `DOMContentLoaded`事件触发代表初始的HTML被完全加载和解析，不需要等待CSS，JS，图片加载。
>
> `Load`事件触发代表页面中的DOM，CSS，JS，图片已经全部加载完毕。

10.最后就是TCP断开连接，四次挥手。

> 客户端：我没有数据要发送了，准备挂了
>
> 服务器：收到，但我还有一些数据没发送完，稍等一下 ......
>
> 服务器：好了，发送完了，可以断开连接了
>
> 客户端：OK，你断开连接吧（内心独白：我将会在2倍的最大报文段生存时间后关闭连接，如果再收到服务器的消息，那么服务器就是没听到我最后这句话，我就再发送一遍）

