## HTTP的概念

http就是超文本传输协议， HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范 。



## 与http相关的概念

1. 浏览器：浏览器实际上是一个http协议中的请求方，在 HTTP 协议里，浏览器的角色被称为“User Agent”即“用户代理”，也被简单的称为客户端
2. 服务器
3. CDN：全称是“Content Delivery Network”，翻译过来就是“内容分发网络”。它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求，主要起着缓存加速的作用。
4. https：HTTPS 的全称是“HTTP over SSL/TLS”，也就是运行在 SSL/TLS 协议上的 HTTP。 HTTPS 相当于“HTTP+SSL/TLS+TCP/IP”



## http几种请求方法

- GET
- POST
- PUT
- HEAD：方法与 GET 方法类似，也是请求从服务器获取资源，服务器的处理机制也是一样的，但服务器不会返回请求的实体数据，只会传回响应头，也就是资源的“元信息”。
- DELETE
- OPTIONS：方法要求服务器列出可对资源实行的操作方法，在响应头的 Allow 字段里返回。它的功能很有限，用处也不大，有的服务器（例如 Nginx）干脆就没有实现对它的支持。
- CONNECT：是一个比较特殊的方法，要求服务器为客户端和另一台远程服务器建立一条特殊的连接隧道，这时 Web 服务器在中间充当了代理的角色。 
- TRACE：方法多用于对 HTTP 链路的测试或诊断，可以显示出请求 - 响应的传输路径。它的本意是好的，但存在漏洞，会泄漏网站的信息，所以 Web 服务器通常也是禁止使用。

### 安全与幂等

安全：在 HTTP 协议里，所谓的“安全”是指请求方法不会“破坏”服务器上的资源，即不会对服务器上的资源造成实质的修改。  

按照这个定义，只有 GET 和 HEAD 方法是“安全”的，因为它们是“只读”操作，只要服务器不故意曲解请求方法的处理方式，无论 GET 和 HEAD 操作多少次，服务器上的数据都是“安全的”。而 POST/PUT/DELETE 操作会修改服务器上的资源，增加或删除数据，所以是“不安全”的。



幂等：所谓的“幂等”实际上是一个数学用语，被借用到了 HTTP 协议里，意思是多次执行相同的操作，结果也都是相同的，即多次“幂”后结果“相等”。

GET,HEAD,PUT幂等，POST不是





## HTTP连接管理

### 短连接

在0.9和1.0时代，http使用的是短连接，他底层的数据传输基于TCP/IP协议，每次发送请求要有三次握手，结束后又有四次挥手，因为客户端与服务器连接的时间很短，所以被称为短连接

### 长链接

http1.1默认使用长连接，不需要什么特殊的头字段指定，只要向服务器发起一次请求，后续的请求就会重复利用第一次打开的TCP链接，也就是长连接，在这个链接上收发数据。

如果想在请求头中明确的要求使用使用长连接，那么字段就是Connection，值为keep-alive。

但是如果一直维持长连接，服务器就必须在内存中保存TCP的状态，如果大量空闲连接只连接不发送，那么很快会耗尽服务器资源。

所以在客户端的请求头加上Connection:close字段，就能告诉服务器这次通信结束后就关闭链接，服务器看到以后，就会在响应报文里也加上这个字段，发送以后调用socket API关闭TCP连接

另外，客户端和服务器都可以在报文里附加通用头字段“Keep-Alive: timeout=value”，限定长连接的超时时间。但这个字段的约束力并不强，通信的双方可能并不会遵守，所以不太常见。



### 队头阻塞

队头阻塞与长短连接无关，是由http基本的请求-应答模型导致的。

因为 HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本。

#### 性能优化

就像打卡机一样，可以买多台打卡机解决这个问题，就是http中的**并发连接**，也就是同时对同一个域名发起多个长连接，但是如果每个客户端都建立很多个链接，服务器的资源也扛不住，会被服务器当做恶意攻击，从而拒绝服务。浏览器允许每个客户端并发6-8的连接。

后来还发展出一个更厉害的方法，就是**域名分片**技术，多开几个域名，全部指向同一台服务器，这样长连接的数量又上去了。

这两种方法都使用数量解决质量问题。

一般使用长连接，除非明确知道只会发送一个请求，比如游戏内连接兑换码服务进行礼包兑换。 

1，服务器端设置keepalive＿timeout表示多长时间没有数据则关闭连接。 

2，服务器端设置keepalive_requests，表示该连接上处理多少个请求后关闭连接。 

3，服务器端设置最大连接数，当连接达到上限之后拒绝连接，也可以采用限流措施等。 

4，客户端设置keepalive_requests，表示该连接上发送多少个连接后关闭连接。 

5，客户端设置keepalive_timeout，表示多长时间没有数据发送则关闭连接。 

6，客户端设置响应超时后重试次数，当次数达到上限后关闭连接。 



## 重定向

浏览器收到301/302报文，会检查响应头有没有**Location**字段，如果有，就从字段值中提取URI，发出新的http请求，相当于替用户点击了这个链接。

重定向返回的URI可以是不完整的，他会从请求上下文里计算得到，但是如果要重定向到站外，就必须用完整的URI。

重定向报文里还可以用**refresh**字段，告诉浏览器几秒钟以后再跳转



## Cookie

响应头字段set-cookie，请求头字段cookie。

当用户第一次访问服务器时，服务器不知道用户的身份，所以要创建一个独一无二的身份标识，格式是键值对，放进set-cookie字段中，再发给浏览器。

浏览器收到响应报文，保存这个set-cookie，等下次在请求的时候放进cookie字段里发给服务器。

服务器收到响应报文，看到了cookie，知道这个用户不是新人，就拿出cookie中的值，识别用户身份。

服务器有时会设置多个set-cookie，但是浏览器请求时只要设置一个，将键值对用分号隔开



### 防止cookie外泄

#### 设置cookie有效期

1. expires：过期时间，是绝对时间点，指一个具体的截止日期
2. max-age：浏览器会优先采用，相对时间，单位是秒，浏览器接收到报文的时间点再加上max-age，就是失效时间

#### 设置cookie作用域

设置**domain**和**path**，指定cookie所属域名和路径，浏览器在发送cookie前，会从uri中提取host和path部分，与这两个属性进行比对。



#### cookie安全性

通过设置**httponly**属性，告诉浏览器，此cookie只能通过浏览器http协议传输，禁止其他方式访问。

另一个属性**samesite**可以防范csrf，值为strict可以严格限制cookie不能随着跳转链接跨站发送

而lax则可以宽松一点，允许get和head方法，但禁止post跨站发送

还有一个属性叫“Secure”，表示这个 Cookie 仅能用 HTTPS 协议加密传输，明文的 HTTP 协议会禁止发送。但 Cookie 本身不是加密的，浏览器里还是以明文的形式存在。





## HTTP的缓存控制

### 服务端缓存控制

1. 浏览器发现缓存无数据，于是发送请求，向服务器获取资源；
2. 服务器响应请求，返回资源，同时标记资源的有效期；
3. 浏览器缓存资源，等待下次重用。

可以在响应头中设置cache-control，里面的值为max-age = 30，告诉浏览器用这个页面只能缓存30s，但这包括了数据在其它层传输的所有时间，还有其他字段

no-store：不允许缓存，用于某些变化非常频繁的数据，例如秒杀页面；

no-cache：它的字面含义容易与 no-store 搞混，实际的意思并不是不允许缓存，而是可以缓存，但在使用之前必须要去服务器验证是否过期，是否有最新的版本；

must-revalidate：又是一个和 no-cache 相似的词，它的意思是如果缓存不过期就可以继续使用，但过期了如果还想用就必须去服务器验证。



### 客户端缓存控制

点击刷新按钮时，浏览器会在请求头里加一个cache-control:max-age=0,浏览器会用一个最新生成的报文回应浏览器。

缓存究竟何时才会生效？

点击浏览器的前进，后退按钮，会发现读取的是磁盘上的缓存，没有发送网络请求。



#### 条件请求

本来应该是head+get合起来才能完成的事情，现在用一系列if开头的字段解决。

第一次响应的报文预先提供last-modified（文件最后修改时间）和ETag（实体标签），然后第二次请求时就可以带上缓存里的原值，验证资源是否是最新，如果资源没有变，就会返回一个304not modified表示缓存依然有效

ETag是资源的一个唯一标识符，因为有些文件在一秒内修改了多次，所以这一秒内的新版本无法区分，有些文件定期更新，但有时是同样的内容，实际上无变化，用修改时间就会误以为发生了变化。

ETag也有强弱之分，弱etag只要求资源在语义上无变化，ruguohtml标签顺序调整或者多了几个空壳，也可以。



#### Last-Modified和if-Modified-Since

这是一对，last-modified是响应头，表示资源最新修改时间，if-modified-since是请求头，也是资源最新修改时间（其实就是上次服务器给的last-modified），由浏览器告诉服务器，两者进行比较，如果last-modified和if-modified-since相同，那么就会返回304

#### ETag和if-None-Match

但是如果文件在一秒内就改变，那么上一种方法就没用了，

if-none-match保存着服务器传来的etag，然后请求时，与服务器端的etag对比，如果相同，就直接用缓存中文件。

#### http缓存工作方式

1. 让服务器与浏览器约定一个过期时间--expiers （强缓存）
2. 在约定过期时间基础上再加上一个文件最新修改时间对比，也就是last-modified和if-modified-since （协商缓存）
3. 在前两者的基础上再加上etag和if-none-match，再加一个max-age（协商缓存）



### 缓存改进方式

1. md5/hash
2. cdn