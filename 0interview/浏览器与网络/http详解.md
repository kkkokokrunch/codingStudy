## HTTP的概念

http就是超文本传输协议， HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范 。



## HTTP历史

#### http0.9

只能用get方法从服务器获取html文档，传输数据仅限于文本

#### http1.0

- 新增POST,HEAD方法
- 增加了响应状态码
- 引入了协议版本号
- 引入了http header（头部）的概念
- 传输的数据不仅限于文本

但是HTTP1.0只是一份参考文档

#### http1.1

http1.1才是一个正式标准

- 新增PUT,DELETE方法
- 增加了缓存控制和管理
- 允许响应数据分块，有利于传输大文件
- 强制要求host头



#### http2

基于 Google 的 SPDY 协议，在性能改善方面做了很大努力

- 二进制协议，不再是纯文本
- 可发起多个请求，废弃了1.1中的管道
- 使用算法进行头部压缩，减少数据传输量
- 允许服务器主动向客户端推送数据
- 增强安全性，要求加密通信

#### http3



## DNS

比如你有一个网站要上线，你在域名注册商那里申请了abc.com,那么你的域名A记录就保存在这个域名注册商的DNS服务器上，该DNS服务器称为权威域名服务器。

当客户端访问abc.com时，先查找浏览器DNS缓存，没有则查找操作系统DNS缓存，在这一阶段是操作系统dnscache clinet 服务进行DNS缓存的（你在任务管理器里面可以看到一个dns客户端进程，就是这玩意实现缓存的），

如果还是没有则查找hosts文件中的域名记录。

然后依然没有的话则访问电脑上设置的DNS服务器IP，比如三大营运商的dns服务器或者谷歌的8.8.8.8，此时这一层的DNS服务器称为“野生DNS缓存服务器”，也就是非权威域名服务器。

如果还是没有则非权威域名服务器会去查找 根域名服务器-顶级域名服务器-二级域名服务器-权威域名服务器 ，这样客户端就在权威域名服务器上找到了abc.com对应的IP了，这个IP可以是多个，每次客户端请求的时候域名服务器会根据负载均衡算法分配一个IP给你。当DNS缓存失效了，则重新开始新一轮的域名请求。
总结如下：
浏览器缓存->操作系统dnscache ->hosts文件->非权威域名服务器->根域名服务器->顶级域名服务器->二级域名服务器->权威域名服务器。
其中非权威域名服务器还包括LDNS（企业内网DNS服务器），三大营运商DNS，谷歌公开的DNS，微软公开的DNS等。
另外DNS请求有两种方式：递归查询和迭代查询

## 与http相关的概念

1. 浏览器：浏览器实际上是一个http协议中的请求方，在 HTTP 协议里，浏览器的角色被称为“User Agent”即“用户代理”，也被简单的称为客户端
2. 服务器
3. CDN：全称是“Content Delivery Network”，翻译过来就是“内容分发网络”。它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求，主要起着缓存加速的作用。
4. https：HTTPS 的全称是“HTTP over SSL/TLS”，也就是运行在 SSL/TLS 协议上的 HTTP。 HTTPS 相当于“HTTP+SSL/TLS+TCP/IP”



## http报文结构

报文结构：header+body，header后会有一个空行，空行以后都是body

请求头：请求行+头部字段 （请求行：请求方法+请求目标（URL）+http版本号  GET /09-1 HTTP/1.1）

响应头：状态行+头部字段 （状态行：http版本号+状态码+原因字符串 HTTP/1.1 400 Bad Request ） 



头部字段是key-value形式：

请求头：User-Agent（浏览器名字），Accept,Accept-language,Cookie，Accept-Encoding: 

gzip, deflate, br（客户端支持的压缩方式，其中gzip只能压缩文本）

响应头：Date，Content-type，Connection，Set-Cookie，如果没有Content-Encoding代表没有被压缩

## http几种请求方法

- GET
- POST
- PUT：比如userinfo，包含了userId，userName，userAge等，用put要求前端提供一个完整的资源对象，如果只想更改userName，使用PATCH就可以只传一个userName，减少带宽的浪费。
- HEAD：方法与 GET 方法类似，也是请求从服务器获取资源，服务器的处理机制也是一样的，但服务器不会返回请求的实体数据，只会传回响应头，也就是资源的“元信息”。
- DELETE
- OPTIONS：方法要求服务器列出可对资源实行的操作方法，在响应头的 Allow 字段里返回。它的功能很有限，用处也不大，有的服务器（例如 Nginx）干脆就没有实现对它的支持。
- CONNECT：是一个比较特殊的方法，要求服务器为客户端和另一台远程服务器建立一条特殊的连接隧道，这时 Web 服务器在中间充当了代理的角色。 
- TRACE：方法多用于对 HTTP 链路的测试或诊断，可以显示出请求 - 响应的传输路径。它的本意是好的，但存在漏洞，会泄漏网站的信息，所以 Web 服务器通常也是禁止使用。

### 安全与幂等

安全：在 HTTP 协议里，所谓的“安全”是指请求方法不会“破坏”服务器上的资源，即不会对服务器上的资源造成实质的修改。  

按照这个定义，只有 GET 和 HEAD 方法是“安全”的，因为它们是“只读”操作，只要服务器不故意曲解请求方法的处理方式，无论 GET 和 HEAD 操作多少次，服务器上的数据都是“安全的”。而 POST/PUT/DELETE 操作会修改服务器上的资源，增加或删除数据，所以是“不安全”的。



幂等：所谓的“幂等”实际上是一个数学用语，被借用到了 HTTP 协议里，意思是多次执行相同的操作，结果也都是相同的，即多次“幂”后结果“相等”。

POST 是“新增或提交数据”，多次提交数据会创建多个资源，所以不是幂等的；而 PUT 是“替换或更新数据”，多次更新一个资源，资源还是会第一次更新的状态，所以是幂等的。

GET,HEAD,PUT幂等，POST不是



## HTTP传输大文件

1. 数据压缩（Accept-Encoding: gzip, deflate, br，Content-Encoding)
2. 分块传输（响应头Transfer-Encoding: chunked）

## HTTP连接管理

### 短连接

在0.9和1.0时代，http使用的是短连接，他底层的数据传输基于TCP/IP协议，每次发送请求要有三次握手，结束后又有四次挥手，因为客户端与服务器连接的时间很短，所以被称为短连接

### 长链接

http1.1默认使用长连接，不需要什么特殊的头字段指定，只要向服务器发起一次请求，后续的请求就会重复利用第一次打开的TCP链接，也就是长连接，在这个链接上收发数据。

如果想在请求头中明确的要求使用使用长连接，那么字段就是Connection，值为keep-alive。

但是如果一直维持长连接，服务器就必须在内存中保存TCP的状态，如果大量空闲连接只连接不发送，那么很快会耗尽服务器资源。

所以在客户端的请求头加上Connection:close字段，就能告诉服务器这次通信结束后就关闭链接，服务器看到以后，就会在响应报文里也加上这个字段，发送以后调用socket API关闭TCP连接

另外，客户端和服务器都可以在报文里附加通用头字段“Keep-Alive: timeout=value”，限定长连接的超时时间。但这个字段的约束力并不强，通信的双方可能并不会遵守，所以不太常见。



### 队头阻塞

队头阻塞与长短连接无关，是由http基本的请求-应答模型导致的。

因为 HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本。

#### 性能优化

就像打卡机一样，可以买多台打卡机解决这个问题，就是http中的**并发连接**，也就是同时对同一个域名发起多个长连接，但是如果每个客户端都建立很多个链接，服务器的资源也扛不住，会被服务器当做恶意攻击，从而拒绝服务。浏览器允许每个客户端并发6-8的连接。

后来还发展出一个更厉害的方法，就是**域名分片**技术，多开几个域名，全部指向同一台服务器，这样长连接的数量又上去了。

这两种方法都使用数量解决质量问题。

一般使用长连接，除非明确知道只会发送一个请求，比如游戏内连接兑换码服务进行礼包兑换。 

1，服务器端设置keepalive＿timeout表示多长时间没有数据则关闭连接。 

2，服务器端设置keepalive_requests，表示该连接上处理多少个请求后关闭连接。 

3，服务器端设置最大连接数，当连接达到上限之后拒绝连接，也可以采用限流措施等。 

4，客户端设置keepalive_requests，表示该连接上发送多少个连接后关闭连接。 

5，客户端设置keepalive_timeout，表示多长时间没有数据发送则关闭连接。 

6，客户端设置响应超时后重试次数，当次数达到上限后关闭连接。 



## 重定向

浏览器收到301/302报文，会检查响应头有没有**Location**字段，如果有，就从字段值中提取URI，发出新的http请求，相当于替用户点击了这个链接。

重定向返回的URI可以是不完整的，他会从请求上下文里计算得到，但是如果要重定向到站外，就必须用完整的URI。

重定向报文里还可以用**refresh**字段，告诉浏览器几秒钟以后再跳转



## Cookie

响应头字段set-cookie，请求头字段cookie。

当用户第一次访问服务器时，服务器不知道用户的身份，所以要创建一个独一无二的身份标识，格式是键值对，放进set-cookie字段中，再发给浏览器。

浏览器收到响应报文，保存这个set-cookie，等下次在请求的时候放进cookie字段里发给服务器。

服务器收到响应报文，看到了cookie，知道这个用户不是新人，就拿出cookie中的值，识别用户身份。

服务器有时会设置多个set-cookie，但是浏览器请求时只要设置一个，将键值对用分号隔开

### cookie不可跨域

```javascript
javascript:document.cookie='myname=laihuamin;path=/;domain=.baidu.com';
javascript:document.cookie='myname=huaminlai;path=/;domain=.google.com';
```

当打开百度的网页设置cookie时，只有上面那个是有效的，每个cookie都会绑定单一的域名。

### cookie的属性

1. name

2. value

3. domain：指cookie绑定的域名，同一域名下的二级域名也不能交换使用cookie，如www.baidu\.com和image.baidu.com不能共用一个cookie

4. path：web的路由

5. Expires/Max-Age（有效期）：和缓存类似，max-age小于零时，表示临时储存，不生成cookie文件，当浏览器关闭cookie就消失，当max-age=0时，会删除cookie

6. secure：为true时，这个cookie只会在http设ssl等安全协议下传输（不能对客户端cookie加密，不能保证绝对安全）

7. httpOnly：告诉浏览器，此cookie只能通过浏览器http协议传输，禁止其他方式访问，比如通过js脚本获取。可以防止xss攻击。

8. SameSite：SameSite 属性可以让 Cookie 在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击（CSRF）。

   - **Strict** 仅允许一方请求携带 Cookie，即浏览器将只发送相同站点请求的 Cookie，即当前网页 URL 与请求目标 URL 完全一致。

   - **Lax** 允许部分第三方请求携带 Cookie，默认

   - **None** 无论是否跨站都会发送 Cookie

   #### 什么是跨站

   同站：只要两个 URL 的 eTLD+1 相同即可，不需要考虑协议和端口。其中，eTLD 表示有效顶级域名，注册于 Mozilla 维护的公共后缀列表（Public Suffix List）中，例如，.com、.co.uk、.github.io 等。eTLD+1 则表示，有效顶级域名+二级域名，例如 taobao.com 等。

   
   举几个例子，www.taobao.com 和 www.baidu.com 是跨站（.com前一个是taobao一个是百度），www.a.taobao.com 和 www.b.taobao.com 是同站（.com前都是taobao），a.github.io 和 b.github.io 是跨站(注意是跨站)（.github.io 是一级域名，前面一个是a，一个是b）。

### 防止cookie外泄

#### 设置cookie有效期

1. expires：过期时间，是绝对时间点，指一个具体的截止日期
2. max-age：浏览器会优先采用，相对时间，单位是秒，浏览器接收到报文的时间点再加上max-age，就是失效时间

#### 设置cookie作用域

设置**domain**和**path**，指定cookie所属域名和路径，浏览器在发送cookie前，会从uri中提取host和path部分，与这两个属性进行比对。



#### cookie安全性

通过设置**httponly**属性，告诉浏览器，此cookie只能通过浏览器http协议传输，禁止其他方式访问。

另一个属性**samesite**可以防范csrf，值为strict可以严格限制cookie不能随着跳转链接跨站发送

而lax则可以宽松一点，允许get和head方法，但禁止post跨站发送

还有一个属性叫“Secure”，表示这个 Cookie 仅能用 HTTPS 协议加密传输，明文的 HTTP 协议会禁止发送。但 Cookie 本身不是加密的，浏览器里还是以明文的形式存在。





## HTTP的缓存控制

1. 一开始浏览器会检查强缓存，这个时候不需要发送http请求，在http1.0中通过服务器返回的响应头中的Expires字段，这个字段是一个具体的过期时间，但是服务器和浏览器的时间可能不一致，所以被弃用了
2. 在http1.1中，改用cache-control字段，也是存在于服务器返回的响应头中，采用的是相对时间max-age来判断

```
Cache-Control:max-age=3600

private： 这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。

no-cache: 跳过当前的强缓存，发送HTTP请求，即直接进入协商缓存阶段。

no-store：非常粗暴，不进行任何形式的缓存。

s-maxage：这和max-age长得比较像，但是区别在于s-maxage是针对代理服务器的缓存时间。

must-revalidate: 是缓存就会有过期的时候，加上这个字段一旦缓存过期，就必须回到源服务器验证。

```

值得注意的是，当Expires和Cache-Control同时存在的时候，Cache-Control会优先考虑。

3. 当强缓存的时间超过了，强缓存就会失效，然后进入协商缓存
4. 浏览器在请求头中携带相应的缓存tag向服务器发送请求，服务器通过这个tag来决定是否使用缓存
   - 浏览器第一次发送请求给服务器后，服务器会在响应头中加上`Last-modified`字段，表示最后修改时间，浏览器收到后，会在下次请求时，携带`If-Modified-Since`字段，这个字段的值也就是服务器传来的`Last-modified`。然后两者进行比较，如果请求头发来的`If-Modified-Since`小于现在服务器中的`Last-modified`，那么就返回新的资源，否则返回304，告诉浏览器直接用缓存
   - etag则是服务器根据资源内容生成的哈希值，一旦文章内容发生改变，`etag`也会变，流程与`last-modified`一样,它对应的是`if-none-match`
   - 在精确度上，etag高于last-modified，在性能上last-modified优于etag，服务器优先考虑etag。

### 服务端缓存控制

1. 浏览器发现缓存无数据，于是发送请求，向服务器获取资源；
2. 服务器响应请求，返回资源，同时标记资源的有效期；
3. 浏览器缓存资源，等待下次重用。

可以在响应头中设置cache-control，里面的值为max-age = 30，告诉浏览器用这个页面只能缓存30s，但这包括了数据在其它层传输的所有时间，还有其他字段

no-store：不允许缓存，用于某些变化非常频繁的数据，例如秒杀页面；

no-cache：它的字面含义容易与 no-store 搞混，实际的意思并不是不允许缓存，而是可以缓存，但在使用之前必须要去服务器验证是否过期，是否有最新的版本；

must-revalidate：又是一个和 no-cache 相似的词，它的意思是如果缓存不过期就可以继续使用，但过期了如果还想用就必须去服务器验证。



### 客户端缓存控制

点击刷新按钮时，浏览器会在请求头里加一个cache-control:max-age=0,浏览器会用一个最新生成的报文回应浏览器。

缓存究竟何时才会生效？

点击浏览器的前进，后退按钮，会发现读取的是磁盘上的缓存，没有发送网络请求。



#### 条件请求

本来应该是head+get合起来才能完成的事情，现在用一系列if开头的字段解决。

第一次响应的报文预先提供last-modified（文件最后修改时间）和ETag（实体标签），然后第二次请求时就可以带上缓存里的原值，验证资源是否是最新，如果资源没有变，就会返回一个304not modified表示缓存依然有效

ETag是资源的一个唯一标识符，因为有些文件在一秒内修改了多次，所以这一秒内的新版本无法区分，有些文件定期更新，但有时是同样的内容，实际上无变化，用修改时间就会误以为发生了变化。

ETag也有强弱之分，弱etag只要求资源在语义上无变化，ruguohtml标签顺序调整或者多了几个空壳，也可以。



#### Last-Modified和if-Modified-Since

这是一对，last-modified是响应头，表示资源最新修改时间，if-modified-since是请求头，也是资源最新修改时间（其实就是上次服务器给的last-modified），由浏览器告诉服务器，两者进行比较，如果last-modified和if-modified-since相同，那么就会返回304

#### ETag和if-None-Match

但是如果文件在一秒内就改变，那么上一种方法就没用了，

if-none-match保存着服务器传来的etag，然后请求时，与服务器端的etag对比，如果相同，就直接用缓存中文件。

#### http缓存工作方式

1. 让服务器与浏览器约定一个过期时间--expiers （强缓存）
2. 在约定过期时间基础上再加上一个文件最新修改时间对比，也就是last-modified和if-modified-since （协商缓存）
3. 在前两者的基础上再加上etag和if-none-match，再加一个max-age（协商缓存）



### 缓存改进方式

1. md5/hash
2. cdn