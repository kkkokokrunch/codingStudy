## 从输入url到加载完成中间发生了什么？
0. 先检查浏览器有没有缓存，如果有缓存且没有过期，就直接用缓存的内容，如果没有缓存就开始下一步
1. 首先是**DNS解析**：如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来，如果没有的话，会进行DNS迭代查询。

2. 之后就是**TCP握手**：TCP 的握手情况以及 TCP 的一些特性。如果是https的话，还会 TCP 握手结束后就会进行 TLS 握手，然后就开始正式的传输数据。

   **应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了。**

   **数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件。**

3. 接收到响应的文件之后，**首先浏览器会判断状态码是什么**，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向

4. **浏览器开始解析文件**，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件。

5. 文件解码成功后会正式开始**渲染流程**，解析 HTML 文档，构件 DOM 树，下载资源，构造 CSSOM 树，执行 js 脚本，这些操作没有严格的先后顺序，以下分别解释
-  **构建 DOM 树**：
    1. **Tokenizing**：根据 HTML 规范将字符流解析为标记
    2. **Lexing**：词法分析将标记转换为对象并定义属性和规则
    3. **DOM construction**：根据 HTML 标记关系将对象组成 DOM 树
-  解析过程中遇到图片、样式表、js 文件，**启动下载**
-  构建**CSSOM 树**：
    1. **Tokenizing**：字符流转换为标记流
    2. **Node**：根据标记创建节点
    3. **CSSOM**：节点创建 CSSOM 树
-  **[根据 DOM 树和 CSSOM 树构建布局（渲染）树](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction)**:
    1. 渲染进程将HTML内容转换为能够读懂的DOM树结构。
    2. 渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets，计算出DOM节点的样式。
    3. 创建布局树，并计算元素的布局信息。
    4. 对布局树进行分层，并生成分层树。
    5. 为每个图层生成绘制列表，并将其提交到合成线程。
    6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
    7. 合成线程发送绘制图块命令DrawQuad给浏览器进程。
    8. 浏览器进程根据DrawQuad消息生成页面，并显示到显示器上

8. **js 解析如下**：

1. 浏览器创建 Document 对象并解析 HTML，将解析到的元素和文本节点添加到文档中，此时**document.readystate 为 loading**
2. HTML 解析器遇到**没有 async 和 defer 的 script 时**，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用 document.write()把文本插入到输入流中。**同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作 script 和他们之前的文档内容**
3. 当解析器遇到设置了**async**属性的 script 时，开始下载脚本并继续解析文档。脚本会在它**下载完成后尽快执行**，但是**解析器不会停下来等它下载**。异步脚本**禁止使用 document.write()**，它们可以访问自己 script 和之前的文档元素
4. 当文档完成解析，document.readState 变成 interactive
5. 所有**defer**脚本会**按照在文档出现的顺序执行**，延迟脚本**能访问完整文档树**，禁止使用 document.write()
6. 浏览器**在 Document 对象上触发 DOMContentLoaded 事件**
7. 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些**内容完成载入并且所有异步脚本完成载入和执行**，document.readState 变为 complete,window 触发 load 事件

> 另外就是：
>
> `DOMContentLoaded`事件触发代表初始的HTML被完全加载和解析，不需要等待CSS，JS，图片加载。
>
> `Load`事件触发代表页面中的DOM，CSS，JS，图片已经全部加载完毕。

10.最后就是TCP断开连接，四次挥手。

> 客户端：我没有数据要发送了，准备挂了
>
> 服务器：收到，但我还有一些数据没发送完，稍等一下 ......
>
> 服务器：好了，发送完了，可以断开连接了
>
> 客户端：OK，你断开连接吧（内心独白：我将会在2倍的最大报文段生存时间后关闭连接，如果再收到服务器的消息，那么服务器就是没听到我最后这句话，我就再发送一遍）



## http是什么
基本概念：

HTTP，全称为 HyperText Transfer Protocol，即为超文本传输协议。是互联网应用最为广泛的一种网络协议
所有的 www 文件都必须遵守这个标准。

http特性：

HTTP 是无连接无状态的 简单快速 灵活
HTTP 一般构建于 TCP/IP 协议之上，默认端口号是 80
HTTP 可以分为两个部分，即请求和响应。

http请求：

HTTP 定义了在与服务器交互的不同方式，最常用的方法有 4 种
分别是 GET，POST，PUT， DELETE。URL 全称为资源描述符，可以这么认为：一个 URL 地址
对应着一个网络上的资源，而 HTTP 中的 GET，POST，PUT，DELETE 
就对应着对这个资源的查询，修改，增添，删除4个操作。

HTTP 请求由 4 个部分构成，分别是：请求行，请求头(Request Header)，空行，请求正文。

HTTP 响应由 4 个部分构成，分别是：状态行，响应头(Response Header)，空行，响应正文。

HTTP 响应中包含一个状态码，用来表示服务器对客户端响应的结果。
状态码一般由3位构成：

1xx : 表示请求已经接受了，继续处理。
2xx : 表示请求已经处理掉了。
3xx : 重定向。
4xx : 一般表示客户端有错误，请求无法实现。
5xx : 一般为服务器端的错误。


## 常见状态码
1. 200 OK 客户端请求成功。
2. 301 Moved Permanently 请求永久重定向 所请求的页面被转移到新的URL。
3. 302 Moved Temporarily 请求临时重定向 所请求的页面被临时转移到新的URL。
4. 304 Not Modified 文件未修改，可以直接使用缓存的文件。
5. 400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。
6. 401 Unauthorized 请求未经授权，无法访问。
7. 403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因。
8. 404 Not Found 请求的资源不存在，比如输入了错误的URL。
9. 500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。
10. 503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。


## HTTP持久连接
HTTP协议采用‘请求-应答’模式，当使用普通模式的时候，每个请求或应答客户和服务器都要重新建一个链接  
完成之后立即断开连接（因为http协议为无连接的协议）  
当时用keep-alive模式（持久连接、链接重用）时，keep-alive功能使客户端到服务器端的连接持续有效，  
当出现对服务器的后继请求时，keep-alive功能避免了建立或者重新建立连接

## 管线化
在持久连接的情况下，将请求一次打包传过去，将响应一次打包接收  
仅有get和head请求可以管线化


## TCP和UDP
TCP与UDP区别总结：

1. TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接

2. TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付

3. TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的

UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）

4. 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信

5. TCP首部开销20字节;UDP的首部开销小，只有8个字节

## 三次握手和四次挥手
客户端和服务器会用三次握手的形式建立连接，数据传输完成以后，用四次挥手的形式结束链接


## cache-control
特性：
1. 可缓存性：
   - public（http经过的任何地方都可以缓存） 
   - private（只有发起请求的浏览器才可以缓存）
   - no-cache （任何节点都不能缓存）

2. 到期
   - max-age=<seconds> 缓存内容多久到期
   - s-maxage=<seconds> 只有在代理服务器中才会生效
   - max-stale=<seconds> 就算max-age过期了，还可以在max-stale时间内使用过期的缓存

