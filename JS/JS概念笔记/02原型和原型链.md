## 原型和原型链

### 构造函数
```
function Foo(name, age) {
            this.name = name
            this.age = age
            this.class = 'class-1'
                // return this 默认有这一行
        }

var f = new Foo('张三', 20)
    // var f1 = new Foo('李四', 22) 创建多个对象
```
构造函数默认以大写字母开头
### 构造函数- 扩展
- var a = {} 其实是 var a = new Object()的语法糖
- var a = [] 其实是 var a = new Array()的语法糖
- function Foo(){...}其实是 var Foo = new Function(...)
- 使用instanceof判断一个函数是否是一个变量的构造函数
### 原型规则和示例

```
var obj = {}
obj.a = 100

var arr = []
arr.a = 100

function fn() {}
fn.a = 100

console.log(obj.__proto__)
console.log(arr.__proto__)
console.log(fn.__proto__)

console.log(fn.prototype)

console.log(obj.__proto__ === Object.prototype)
```
1. 所有的引用类型（数组，对象，函数）都具有对象特性，既可以自由扩展属性（除了null以外）
2. 所有的引用类型（数组，对象，函数），都有一个__proto__(隐式原型)，属性值是一个普通的对象
3. 所有的函数都有一个prototype属性，属性值也是一个普通的对象
4. 所有的引用类型（数组，对象，函数），__proto__属性值指向它的构造函数的"prototype"属性值
5. 当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去他的__proto__（既他的构造函数的prototy）中寻找
```
//构造函数
function Foo(name, age) {
    this.name = name
}
Foo.prototype.alertName = function() {
    alert(this.name)
}

//创建实例
var f = new Foo('张三')
f.printName = function() {
    console.log(this.name)
}

//测试
f.printName() //张三
f.alertName() //张三
f.toString() //要去f.__proto__.__proto__中查找
```

循环对象自身的属性
```
var item
for(item in f) {
    //高级浏览器已经在for in中屏蔽了来自原型的属性
    //为了保证程序的健壮性，还是加上这个判断
    if (f.hasOwnProperty(item)) {
        console.log(item)
    }
}
```
### 原型链
![原型链.png](./原型链.png "原型链")
### instanceof
f instanceof Foo的判断逻辑是：
1. f的__proto__一层一层往上，能否对应到Foo.prototype
2. 再试着判断f instanceof Object

### 例题
1. 写一个原型链继承的例子
```
function Animal() {
    this.eat = function() {
        console.log('animal eat')
    }
}

function Dog() {
    this.bark = function() {
        console.log('dog bark')
    }
}

Dog.prototype = new Animal()

var hashiqi = new Dog()
```

2. 描述new一个对象的过程
    1.创建一个新对象
    2.this指向这个新对象
    3.执行代码，即对this赋值
    4.返回this
